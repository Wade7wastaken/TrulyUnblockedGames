const fs = require("fs");
const htmlminifier = require("html-minifier");
const csso = require("csso");
const UglifyJS = require("uglify-js");

const ignored_folders = ["Output", "Scripts", "N64Wasm"]; // skip these folders
const ignored_endings = ["md"]; // skip files with these endings
const endings_to_process = ["css", "js", "json", "html"]; // only read and process files with these endings, only copy others

// rmSync will error if Output doesn't exist
try {
	fs.rmSync("./Output", { recursive: true });
} catch (error) {
	console.log(error);
}

// a simple recursive function that reads all the items in a directory (loc)
// and if it's a file, process it, and if it's a directory
// call this function again
function loop(loc) {
	const dir = fs.opendirSync(loc);
	let dirent;
	// while the next item is not null
	while ((dirent = dir.readSync()) !== null) {
		// filter out git and other hidden files and directories
		if (dirent.name[0] != ".") {
			// if it's a file, then process it
			if (dirent.isFile()) {
				const ending = dirent.name.split(".").splice(-1)[0]; // splits the name on every "." and gets the last one
				const path = loc + "/" + dirent.name; // adds the file name to the location
				// big if statement to see if a file should be processed
				if (
					!ignored_endings.includes(ending) && // exclude if the ending is not in ignored_endings
					(!loc.includes("EmulatorJS") || loc.includes("data")) && // exclude all other folders in EmulatorJS except data
					!(loc.includes("EmulatorJS") && loc.includes("minify")) && // exclude minify in EmulatorJS (its in data so the previous doesn't catch it)
					!(loc.includes("EmulatorJS") && ending == "html") // exclude any html files in EmulatorJS
				) {
					// if the ending should be processed
					if (endings_to_process.includes(ending)) {
						// read as utf-8
						const contents = fs.readFileSync(path, "utf8");
						let min = contents;

						switch (ending) {
							case "html": {
								min = htmlminifier.minify(contents, {
									collapseBooleanAttributes: true,
									collapseInlineTagWhitespace: true,
									collapseWhitespace: true,
									continueOnParseError: true,
									html5: true,
									includeAutoGeneratedTags: false,
									minifyCSS: true,
									minifyJS: true,
									minifyURLs: true,
									quoteCharacter: '"',
									//removeAttributeQuotes: true, // prettier doesnt like this
									removeComments: true,
									removeEmptyAttributes: true,
									removeOptionalTags: true,
									removeRedundantAttributes: true,
									removeScriptTypeAttributes: true,
									removeStyleLinkTypeAttributes: true,
									sortAttributes: true,
									sortClassName: true,
									useShortDoctype: true,
								});
								break;
							}
							case "css": {
								min = csso.minify(contents, {
									comments: false,
									restructure: true,
								}).css;
								break;
							}
							case "js": {
								min = UglifyJS.minify(contents, {}).code;

								break;
							}
							case "json": {
								min = UglifyJS.minify(contents, {
									expression: true,
									output: {
										quote_keys: true,
									},
								}).code;

								break;
							}
						}

						const outfile = "./Output" + path.slice(1);
						let outdir = outfile.split("/").slice(0, -1).join("/");

						// create the folders before writing the file

						fs.mkdirSync(outdir, { recursive: true });

						fs.writeFileSync(outfile, min);

						console.log("File: " + path);
					} else {
						// if not, then just copy the files
						const outfile = "./Output" + path.slice(1);
						let outdir = outfile.split("/").slice(0, -1).join("/");
						fs.mkdirSync(outdir, { recursive: true });
						fs.copyFileSync(path, outfile);
						console.log("File: " + path);
					}
				}
				// if it's a folder, then recursively call the function again
			} else if (dirent.isDirectory()) {
				// skip if the folder is ignored
				if (!ignored_folders.includes(dirent.name)) {
					loop(loc + "/" + dirent.name);
				}
			}
		}
	}
	dir.closeSync();
}

loop(".");
